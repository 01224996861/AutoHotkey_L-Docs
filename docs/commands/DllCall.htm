<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>DllCall</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../css/commands.css" rel="stylesheet" type="text/css">
<link href="../css/print.css" rel="stylesheet" type="text/css" media="print">
</head>
<body>

<h1>DllCall()</h1>
<hr size="2">
<p>Calls a function inside a DLL, such as a standard Windows API function.</p>

<p class="CommandSyntax">Result := DllCall(&quot;[DllFile\]Function&quot; [, Type1, Arg1, Type2, Arg2, &quot;Cdecl ReturnType&quot;])</p>
<h4>Parameters</h4>
<table border="1" width="100%" cellspacing="0" cellpadding="3" bordercolor="#C0C0C0">
  <tr>
    <td width="15%">Result</td>
    <td width="85%">DllCall returns the actual value returned by the function. If the function is of a type that does not return a value, the result is an undefined integer. If the function cannot be called due to an <a href="#error">error</a>, the return value is blank (an empty string).</td>
  </tr>
  <tr>
    <td>[DllFile\]Function</td>
    <td><p>The DLL or EXE file name followed by a backslash and the name of the function. For example: &quot;MyDLL\MyFunction&quot; (the file extension &quot;.dll&quot; is the default when omitted). If an absolute path isn't specified, <em>DllFile</em> is assumed to be in the system's PATH or <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>.</p>
      <p><em><a name="std"></a>DllFile</em> may be omitted when calling a function that resides in User32.dll, Kernel32.dll, ComCtl32.dll, or Gdi32.dll. For example, &quot;User32\IsWindowVisible&quot; produces the same result as &quot;IsWindowVisible&quot;. For these standard DLLs, the letter &quot;A&quot; suffix that appears on some API functions may also be omitted. For example, &quot;MessageBox&quot; is the same as &quot;MessageBoxA&quot;.</p>
      <p>Performance can be dramatically improved when making <em>repeated</em> calls to a DLL by <a href="#load">loading it beforehand</a>.</p>
    <p>In v1.0.46.08+, this parameter may also consist solely of an an integer, which is interpreted as the address of the function to call. Sources of such addresses include <a href="#COM">COM</a> and <a href="RegisterCallback.htm">RegisterCallback()</a>.</p></td>
  </tr>
  <tr>
    <td>Type1, Arg1</td>
    <td>Each of these pairs represents a single parameter to be passed to the function. The number of pairs is unlimited. For <em>Type</em>, see the <a href="#types">types table</a> below. For <em>Arg</em>, specify the value to be passed to the function.</td>
  </tr>
  <tr>
    <td>Cdecl ReturnType</td>
    <td><p><a name="cdecl"></a>The word <em>Cdecl</em> is normally omitted because most functions use the standard calling convention rather than the &quot;C&quot; calling convention (functions such as wsprintf that accept a varying number of arguments are one exception to this). If you omit Cdecl but the call yields <a href="#An">ErrorLevel A<strong>n</strong></a> -- where <strong>n</strong> is the total size of the arguments you passed -- <em>Cdecl</em> might be required.</p>
      <p>If present, the word <em>Cdecl</em> should be listed before the return type (if any). Separate each word from the next with a space or tab. For example: &quot;Cdecl Str&quot;</p>
      <p><em>ReturnType</em>: If the function returns a 32-bit signed integer (Int), BOOL, or nothing at all, <em>ReturnType</em> may be omitted. Otherwise, specify one of the argument types from the <a href="#types">types table</a> below. The <a href="#asterisk">asterisk suffix</a> is also supported.</p>    </td>
  </tr>
</table>

<h4><a name="types"></a>Types of Arguments and Return Values</h4>
<table border="1" style="width: 100%;" cellspacing="0" cellpadding="3" bordercolor="#c0c0c0">
<tr>
<td>Str</TD>
<td><p><a name="str"></a>A string such as &quot;Blue&quot; or MyVar. If the called function modifies the string and the argument is a naked variable, its contents will be updated. For example, the following call would convert the contents of <em>MyVar</em> to uppercase: DllCall(&quot;CharUpper&quot;, &quot;str&quot;, <em>MyVar</em>)</p>
  <p>However, if the function is designed to store a string larger than a variable's current capacity, ensure that the variable is large enough before calling the function. This can be achieved by calling <a href="VarSetCapacity.htm">VarSetCapacity(<em>MyVar</em>, 123)</a>, where 123 is the length that <em>MyVar</em> must be able to hold.</p>
  <p>A <em>str</em> argument must not be an <a href="../Variables.htm#Expressions">expression</a> that evaluates to a number (such as i+1). If it is, the function is not called and ErrorLevel is set to -2.</p>
  <p>The <a href="#asterisk">asterisk variable</a> &quot;str *&quot; is supported but rarely used. It can be used with functions that expect something like &quot;char **&quot; or &quot;LPSTR *&quot;.</p></TD>
</TR>
<tr>
  <td>AStr</TD>
  <td>[Requires AutoHotkey_L] A string with an 8-bit character size. Equivalent to <em>Str</em> in ANSI builds. Use with functions that expect LPSTR, LPCSTR, LPTSTR, char *, and similar types. See <a href="../Compat.htm#DllCall">Script Compatibility</a> for more details.</TD>
</TR>
<tr>
  <td>WStr</TD>
  <td>[Requires AutoHotkey_L] A string with a 16-bit character size. Equivalent to <em>Str</em> in Unicode builds. Use with functions that expect wchar_t*, WCHAR*, LPWSTR, LPCWSTR, and similar types. See <a href="../Compat.htm#DllCall">Script Compatibility</a> for more details.</TD>
</TR>
<tr>
  <td>Int64</TD>
  <td>A 64-bit integer, whose range is -9223372036854775808 (-0x8000000000000000) to 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</TD>
</TR>
<tr>
  <td>Int</TD>
  <td><p><a name="Int"></a>A 32-bit integer (the most common integer type), whose range is -2147483648 (-0x80000000) to 2147483647 (0x7FFFFFFF). An Int is sometimes called a &quot;Long&quot;.</p>
    <p>An Int should also be used for each BOOL argument expected by a function (a BOOL value should be either 1 or 0).</p>
    <p>An <a href="#unsigned">unsigned</a> Int (UInt) is also used quite frequently, such as for DWORD and COLORREF. It is also used for almost all handles, such as HWND, HBRUSH, and HBITMAP.</p>
    <p>Note: To pass a <strong>NULL</strong> handle or pointer, pass the integer 0.</p></TD>
</TR>
<tr>
  <td>Short</TD>
  <td>A 16-bit integer, whose range is -32768 (-0x8000) to 32767 (0x7FFF). An <a href="#unsigned">unsigned</a> Short (UShort) can be used with functions that expect a WORD.</TD>
</TR>
<tr>
  <td>Char</TD>
  <td>An 8-bit integer, whose range is -128 (-0x80) to 127 (0x7F). An <a href="#unsigned">unsigned</a> character (UChar) can be used with functions that expect a BYTE.</TD>
</TR>
<tr>
  <td>Float</TD>
  <td>A 32-bit floating point number, which provides 6 digits of precision. </TD>
</TR>
<tr>
  <td>Double</TD>
  <td>A 64-bit floating point number, which provides 15 digits of precision. </TD>
</TR>
<tr>
  <td>Ptr</TD>
  <td>[Requires AutoHotkey_L] Signifies that the value is a memory address.</TD>
</TR>
<tr>
  <td>* or P<br>
    (suffix) </TD>
  <td><p><a name="asterisk"></a>Append an asterisk (with optional preceding space) to any of the above types to cause the address of the argument to be passed rather than the value itself (the called function must be designed to accept it). Since the value of such an argument might be modified by the function, whenever a naked variable is passed as the argument, that variable's contents will be updated. For example, the following call would pass the address of MyVar to MyFunction but would also update MyVar to reflect any changes made to it by MyFunction: DllCall(&quot;MyDll\MyFunction&quot;, &quot;int *&quot;, MyVar)</p>
    <p>In general, an asterisk is used whenever a function has an argument type or return type that starts with &quot;LP&quot; (except a string type such as LPSTR, for which <a href="#str">&quot;str&quot;</a> should be used). The most common example is LPDWORD, which is a pointer to a DWORD. Since a DWORD is an unsigned 32-bit integer, use &quot;UInt *&quot; or &quot;UintP&quot; to represent LPDWORD.</p>
    <p>Note: &quot;char *&quot; is not the same as <a href="#str">&quot;str&quot;</a> because &quot;char *&quot; passes the address of an 8-bit number, but <a href="#str">&quot;str&quot;</a> passes the address of a series of characters. Also, it is not necessary to call <a href="VarSetCapacity.htm">VarSetCapacity</a> on asterisk variables in which the function will store numbers.</p></TD>
</TR>
<tr>
  <td>U (prefix) </TD>
  <td><p><a name="unsigned"></a>Prepend the letter U to any of the integer types above to interpret it as an unsigned integer (UInt64, UInt, UShort, and UChar). Strictly speaking, this is necessary only for return values and <a href="#asterisk">asterisk variables</a> because it does not matter whether an argument passed by value is unsigned or signed (except for Int64).</p>
    <p>A 32-bit unsigned integer (UInt) is an appropriate substitute for any DWORD, HWND, or similar argument expected by a function. Also, an HWND value (the handle of a window) is the same as the window's <a href="WinGet.htm">unique ID</a>.</p>
    <p>If a negative integer is specified for an unsigned argument, the integer wraps around into the unsigned domain. For example, when -1 is sent as a UInt, it would become 0xFFFFFFFF. However, this technique is not supported for 64-bit integers (UInt64).</p>
    <p><em>Unsigned</em> 64-bit integers produced by a function are not fully supported. Therefore, to work with numbers greater or equal to 0x8000000000000000, omit the U prefix and interpret any negative values received from the function as large integers. For example, a function that yields -1 as an Int64 is really yielding 0xFFFFFFFFFFFFFFFF if it is designed to yield a UInt64.</p></TD>
</TR>
</TABLE>
<p><strong>Note</strong>: When specifying an argument type or return type that does not contain a space or asterisk, the quotes around it may be omitted. For example, str can be used in place of &quot;str&quot; and CDecl in place of &quot;CDecl&quot;. In addition, the letter P may be used in place of asterisk to allow the quotes to be omitted there as well. For example: UIntP.</p>

<h4><a name="error"></a>ErrorLevel</h4>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> is set to one of the following values to indicate whether the call succeeded or failed.</p>
<p><strong>0</strong>: Success.</p>
<p><strong>-1</strong> (negative 1): The <em>[DllFile\]Function</em> parameter is a floating point number. A string or positive integer is required.</p>
<p><strong>-2</strong>: The <a href="#types">return type</a> or one of the specified <a href="#types">arg types</a> is invalid. This error can also be caused by passing an <a href="../Variables.htm#Expressions">expression</a> that evaluates to a number to a string (<a href="#str">str) </a> argument.</p>
<p><strong>-3</strong>: The specified <em>DllFile</em> could not be accessed. If no explicit path was specified for <em>DllFile</em>, the file must exist in the system's PATH or <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>. This error might also occur if the user lacks permission to access the file.</p>
<p><strong>-4</strong>: The specified function could not be found inside the DLL.</p>
<p><strong>N</strong> (any positive number): The function was called but it aborted with fatal exception number <strong>N</strong> (for example, 0xC0000005 means &quot;access violation&quot;). In such cases, the function returns a blank value (empty string), but any <a href="#asterisk">asterisk variables</a> are still updated. An example of a fatal exception is dereferencing an invalid pointer such as NULL. Since a <a href="#cdecl">Cdecl</a> function never produces the <em>&quot;An&quot;</em> error in the next paragraph, it may generate an exception when too few arguments are passed to it.</p>
<p><strong><a name="An"></a>An</strong> (the letter A followed by an integer <strong>n</strong>): The function was called but was passed too many or too few arguments. &quot;<strong>n</strong>&quot; is the number of bytes by which the argument list was incorrect. If <strong>n</strong> is positive, too many arguments (or arguments that were too large) were passed, or the call requires <a href="#cdecl">CDecl</a>. If <strong>n</strong> is negative, too few arguments were passed. This situation should be corrected to ensure reliable operation of the function. The presence of this error may also indicate that an exception occurred, in which case the function returns a blank value.</p>
<h4>Exceptions and A_LastError</h4>
<p>In spite of the built-in exception handling, it is still possible to crash a script with DllCall. This can happen when a function does not directly generate an exception but yields something inappropriate, such as a bad pointer or a string that is not terminated. This might not be the function's fault if the script passed it an unsuitable value such as a bad pointer or a <a href="#str">&quot;str</a>&quot; with insufficient capacity. A script can also crash when it specifies an inappropriate argument type or return type, such as claiming that an ordinary integer yielded by a function is an <a href="#asterisk">asterisk variable</a> or <a href="#str">str</a>.</p>
<p><a name="LastError"></a>The built-in variable <strong>A_LastError</strong> contains the result of the operating system's GetLastError() function, which is called immediately after the function is called (this has no measurable impact on performance). A_LastError is a number between 0 and 4294967295 (always formatted as decimal, not hexadecimal). Like <a href="../misc/ErrorLevel.htm">ErrorLevel</a>, A_LastError is a per-thread setting; that is, interruptions by other <a href="../misc/Threads.htm">threads</a> cannot change it. However, A_LastError is also set by <a href="Run.htm#LastError">Run/RunWait</a>.</p>
<h4><a name="load"></a>Performance</h4>
<p>When making repeated calls to a DLL, performance can be dramatically improved by loading it explicitly (<em>this is not necessary for a <a href="#std">standard DLL</a> such as User32 because it is always resident</em>). This practice avoids the need for DllCall to internally call LoadLibrary and FreeLibrary each time. For example:</p>
<pre>hModule := DllCall(&quot;<strong>LoadLibrary</strong>&quot;, &quot;str&quot;, &quot;MyFunctions.dll&quot;)  <span class="CodeCom">; Avoids the need for DllCall() in the loop to load the library.</span>
Loop, C:\My Documents\*.*, , 1
    result := DllCall(&quot;MyFunctions\BackupFile&quot;, &quot;str&quot;, A_LoopFileFullPath)
DllCall(&quot;<strong>FreeLibrary</strong>&quot;, &quot;UInt&quot;, hModule)  <span class="CodeCom">; To conserve memory, the DLL may be unloaded after using it.</span></pre>
<p>In v1.0.46.08+, even faster performance can be achieved by looking up the function's address beforehand. For example:</p>
<pre><span class="CodeCom">; In the following example, if the DLL isn't yet loaded, use LoadLibrary in place of GetModuleHandle.</span>
<strong>MulDivProc</strong> := DllCall(&quot;GetProcAddress&quot;, uint, DllCall(&quot;GetModuleHandle&quot;, str, &quot;<strong>kernel32</strong>&quot;), str, &quot;<strong>MulDiv</strong>&quot;)
Loop 500
    DllCall(<strong>MulDivProc</strong>, int, 3, int, 4, int, 3)</pre>
<p>Also, adding the line <a href="_NoEnv.htm">#NoEnv</a> anywhere in the script improves DllCall's performance when unquoted parameter types are used (e.g. int vs. &quot;int&quot;).</p>
<p>Finally, when passing a string-variable to a function that will not change the length of the string, performance is improved by passing the variable <a href="../Variables.htm#amp">by address</a> (e.g. &amp;MyVar) rather than as a <a href="#str">&quot;str</a>&quot; (especially when the string is very long). The following example converts a string to uppercase: DllCall(&quot;CharUpper&quot;, <strong>uint</strong>, <em><strong>&amp;</strong>MyVar</em>)</p>
<h4><a name="struct"></a>Structures and Arrays</h4>
<p>A structure is a collection of <em>members</em> (fields) stored adjacently in memory. Most members tend to be integers.</p>
<p>Functions that accept the address of a structure (or a memory-block array) can be called by storing the structure's raw binary data in a normal variable. The following steps are generally used:</p>
<p>1) Call <a href="VarSetCapacity.htm">VarSetCapacity(MyStruct, 123, 0)</a> to ensure that the target variable is large enough to hold the structure's data. Replace 123 with a number that is at least as large as the size of the structure. Specifying zero as the last parameter is optional; it initializes all members to be binary zero, which is typically used to avoid calling NumPut() as often in the next step.</p>
<p>2) If the target function uses the values initially in the structure, call <a href="../Functions.htm#NumPut">NumPut(123, MyStruct, 4)</a> to initialize any members that should be non-zero. Replace 123 with the integer to be put into the target member (or specify &amp;Var to store the <a href="../Variables.htm#amp">address</a> of a variable). Replace 4 with the offset of the target member (see step #4 for description of &quot;offset&quot;).</p>
<p>3) Call the target function, passing the <a href="../Variables.htm#amp">address</a> of MyStruct as a UInt argument. For example, <em>DllCall(&quot;MyDll\MyFunc&quot;, UInt, <strong>&amp;</strong>MyStruct)</em>. The function will examine and/or change some of the members.</p>
<p>4) Use <a href="../Functions.htm#NumGet">MyInteger := NumGet(MyStruct, 4)</a> to retrieve any desired integers from the structure. Replace 4 with the offset of the target member in the structure. The first member is always at offset 0. The second member is at offset 0 plus the size of the first member (typically 4). Members beyond the second are at the offset of the previous member plus the size of the previous member. Most members -- such as DWORD, Int, and <a href="#Int">other types of 32-bit integers</a> -- are 4 bytes in size.</p>
<p>See <a href="#ExStruct">Structure Examples</a> for actual usages.</p>
<h4>Known Limitations</h4>
<p>When a <a href="../Variables.htm#amp">variable's address</a> (e.g. &amp;MyVar) is passed to a function and that function alters the length of the variable's contents, subsequent uses of the variable may behave incorrectly. To fix this, do one of the following: 1) Pass MyVar as a <a href="#str">&quot;str&quot;</a> argument rather than as a uint/address; 2) In v1.0.44.03+, call <a href="VarSetCapacity.htm#neg1">VarSetCapacity(MyVar, -1)</a> to update the variable's internally-stored length after calling DllCall.</p>
<p>Any binary zero stored in a variable by a function hides all data to the right of the zero; that is, such data cannot be accessed or changed by most commands and functions. However, such data can be manipulated by the address and dereference operators (<a href="../Variables.htm#amp">&amp; and *</a>), as well as DllCall itself.</p>
<p>A function that returns the address of one of the strings that was passed into it might return an identical string in a different memory address than expected. For example calling CharLower(CharUpper(MyVar)) in a programming language would convert <em>MyVar</em>'s contents to lowercase. But when the same is done with DllCall(), <em>MyVar</em> would be uppercase after the following call because CharLower would have operated on a different/temporary string whose contents were identical to <em>MyVar</em>:</p>
<pre>MyVar = ABC
result := DllCall(&quot;CharLower&quot;, <strong><u>str</u></strong>, DllCall(&quot;CharUpper&quot;, str, MyVar, <strong><u>str</u></strong>), str)</pre>
<p>To work around this, change the two underlined &quot;str&quot; values above to UInt. This interprets CharUpper's return value as a pure address that will get passed as an integer to CharLower.</p>
<h4><a name="COM"></a>VBScript, JScript, and Component Object Model (COM)</h4>
<p>VBScript and JScript may be embedded in a script via <a href="http://www.autohotkey.net/%7Eeasycom/">Windows Scripting for AutoHotkey</a>, which also provides access to COM.</p>
<p>Also, COM may be used directly via DllCall as demonstrated at <a href="http://www.autohotkey.com/wiki/index.php?title=COM_Wrappers">www.autohotkey.com/wiki/index.php?title=COM_Wrappers</a>.</p>
<h4>Related</h4>
<p><a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Functions</a>, <a href="SysGet.htm">SysGet</a>, <a href="http://msdn.microsoft.com/library/">MSDN Library</a></p>
<h4>Examples</h4>
<pre class="NoIndent"><span class="CodeCom">; Example: Calls the Windows API function &quot;MessageBox&quot; and report which button the user presses.</span>

WhichButton := DllCall(&quot;MessageBox&quot;, &quot;int&quot;, &quot;0&quot;, &quot;str&quot;, &quot;Press Yes or No&quot;, &quot;str&quot;, &quot;Title of box&quot;, &quot;int&quot;, 4)
MsgBox You pressed button #%WhichButton%.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Example: Changes the desktop wallpaper to the specified bitmap (.bmp) file.</span>

DllCall(&quot;SystemParametersInfo&quot;, UInt, 0x14, UInt, 0, Str, <em>A_WinDir <strong>.</strong> &quot;\winnt.bmp&quot;</em>, UInt, 2)</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Example: Calls the API function &quot;IsWindowVisible&quot; to find out if a Notepad window is visible.</span>

DetectHiddenWindows On
if not DllCall(&quot;IsWindowVisible&quot;, &quot;UInt&quot;, WinExist(&quot;Untitled - Notepad&quot;))  <span class="CodeCom">; WinExist() returns an HWND.</span>
    MsgBox The window is not visible.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Example: Calls the API's wsprintf() to pad the number 432 with leading zeros to make it 10 characters wide (0000000432).</span>

VarSetCapacity(ZeroPaddedNumber, 20)  <span class="CodeCom">; Ensure the variable is large enough to accept the new string.</span>
DllCall(&quot;wsprintf&quot;, &quot;str&quot;, ZeroPaddedNumber, &quot;str&quot;, &quot;%010d&quot;, &quot;int&quot;, 432, &quot;Cdecl&quot;)  <span class="CodeCom">; Requires the Cdecl calling convention.</span>
MsgBox %ZeroPaddedNumber%</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="QPC"></a><span class="CodeCom">; Example: Demonstrates QueryPerformanceCounter(), which gives more precision than <a href="../Variables.htm#TickCount">A_TickCount's</a> 10ms.</span>

DllCall(&quot;QueryPerformanceCounter&quot;, &quot;Int64 *&quot;, CounterBefore)
Sleep 1000
DllCall(&quot;QueryPerformanceCounter&quot;, &quot;Int64 *&quot;, CounterAfter)
MsgBox % &quot;Elapsed QPC time is &quot; . CounterAfter - CounterBefore</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Example: This is a hotkey that temporarily reduces the mouse cursor's speed, which facilitates precise positioning.</span>
<span class="CodeCom">; Hold down the F1 key to slow down the cursor. Release it to return to original speed.</span>

F1::
SPI_GETMOUSESPEED = 0x70
SPI_SETMOUSESPEED = 0x71
<span class="CodeCom">; Retrieve the current speed so that it can be restored later:</span>
<strong>DllCall</strong>(&quot;SystemParametersInfo&quot;, UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMouseSpeed, UInt, 0)
<span class="CodeCom">; Now set the mouse to the slower speed specified in the next-to-last parameter (the range is 1-20, 10 is default):</span>
<strong>DllCall</strong>(&quot;SystemParametersInfo&quot;, UInt, SPI_SETMOUSESPEED, UInt, 0, UInt, <strong>3</strong>, UInt, 0)
KeyWait F1  <span class="CodeCom">; This prevents keyboard auto-repeat from doing the DllCall repeatedly.</span>
return

F1 up::<strong>DllCall</strong>(&quot;SystemParametersInfo&quot;, UInt, 0x71, UInt, 0, UInt, OrigMouseSpeed, UInt, 0)  <span class="CodeCom">; Restore the original speed.</span></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="GetChildHWND"></a><span class="CodeCom">; Example: When passed a window's Unique ID and the text or ClassNN of one of its controls,</span>
<span class="CodeCom">; the following function returns the HWND (unique ID) of that control.</span>
<span class="CodeCom">; v1.0.43.06+: This function has been superseded by the following command, which is more accurate.</span>

<a href="ControlGet.htm#Hwnd">ControlGet, OutputVar, Hwnd,, ClassNN, WinTitle</a></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Example: Monitors the active window and display the position of its vertical scroll bar in its</span>
<span class="CodeCom">; focused control (with real-time updates). This requires v1.0.43.06+ because it uses <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a></span>.

#Persistent
SetTimer, WatchScrollBar, 100
return

WatchScrollBar:
ActiveWindow := WinExist(&quot;A&quot;)
if not ActiveWindow  <span class="CodeCom">; No active window.</span>
    return
ControlGetFocus, FocusedControl, ahk_id %ActiveWindow%
if not FocusedControl  <span class="CodeCom">; No focused control.</span>
    return
<span class="CodeCom">; Display the vertical or horizontal scroll bar's position in a ToolTip:</span>
ControlGet, ChildHWND, Hwnd,, %FocusedControl%, ahk_id %ActiveWindow%
ToolTip % <strong>DllCall</strong>(&quot;GetScrollPos&quot;, &quot;UInt&quot;, ChildHWND, &quot;Int&quot;, 1)  <span class="CodeCom">;  Last parameter is 1 for SB_VERT, 0 for SB_HORZ.</span>
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="file"></a><span class="CodeCom">; Example: This is a working script that writes some text to a file then reads it back into memory (requires v1.0.34+).</span>
<span class="CodeCom">; This method can be used to help performance in cases where multiple files are being read or written simultaneously.</span>

FileSelectFile, FileName, S16,, Create a new file:
if FileName =
    return
GENERIC_WRITE = 0x40000000  <span class="CodeCom">; Open the file for writing rather than reading.</span>
CREATE_ALWAYS = 2  <span class="CodeCom">; Create new file (overwriting any existing file).</span>
hFile := <strong>DllCall</strong>(&quot;CreateFile&quot;, str, FileName, Uint, GENERIC_WRITE, Uint, 0, UInt, 0, UInt, CREATE_ALWAYS, Uint, 0, UInt, 0)
if not hFile
{
    MsgBox Can't open &quot;%FileName%&quot; for writing.
    return
}
TestString = This is a test string.`r`n  <span class="CodeCom">; When writing a file this way, use `r`n rather than `n to start a new line.</span>
<strong>DllCall</strong>(&quot;WriteFile&quot;, UInt, hFile, str, TestString, UInt, StrLen(TestString), UIntP, BytesActuallyWritten, UInt, 0)
<strong>DllCall</strong>(&quot;CloseHandle&quot;, UInt, hFile)  <span class="CodeCom">; Close the file.</span>

<span class="CodeCom">; Now that the file was written, read its contents back into memory.</span>
GENERIC_READ = 0x80000000  <span class="CodeCom">; Open the file for reading rather than writing.</span>
OPEN_EXISTING = 3  <span class="CodeCom">; This mode indicates that the file to be opened must already exist.</span>
FILE_SHARE_READ = 0x1 <span class="CodeCom">; This and the next are whether other processes can open the file while we have it open.</span>
FILE_SHARE_WRITE = 0x2
hFile := <strong>DllCall</strong>(&quot;CreateFile&quot;, str, FileName, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, UInt, 0, UInt, OPEN_EXISTING, Uint, 0, UInt, 0)
if not hFile
{
    MsgBox Can't open &quot;%FileName%&quot; for reading.
    return
}
<span class="CodeCom">; Make the variable empty for testing purposes, but ensure it retains sufficient capacity:</span>
BytesToRead := VarSetCapacity(TestString, StrLen(TestString))
<strong>DllCall</strong>(&quot;ReadFile&quot;, UInt, hFile, str, TestString, UInt, BytesToRead, UIntP, BytesActuallyRead, UInt, 0)
<strong>DllCall</strong>(&quot;CloseHandle&quot;, UInt, hFile)  <span class="CodeCom">; Close the file.</span>
MsgBox The following string was read from the file: %TestString%</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="HideCursor"></a><span class="CodeCom">; Example: Hides the mouse cursor when you press Win+C. To later show the cursor, press Win+C again.</span>
<span class="CodeCom">; This script is from <a href="http://www.autohotkey.com/forum/topic6107.html">www.autohotkey.com/forum/topic6107.html</a></span>

OnExit, ShowCursor  <span class="CodeCom">; Ensure the cursor is made visible when the script exits.</span>
return

ShowCursor:
SystemCursor(&quot;On&quot;)
ExitApp

#c::SystemCursor(&quot;Toggle&quot;)  <span class="CodeCom">; Win+C hotkey to toggle the cursor on and off.</span>

SystemCursor(OnOff=1)   <span class="CodeCom">; INIT = &quot;I&quot;,&quot;Init&quot;; OFF = 0,&quot;Off&quot;; TOGGLE = -1,&quot;T&quot;,&quot;Toggle&quot;; ON = others</span>
{
    static AndMask, XorMask, $, h_cursor
        ,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13 <span class="CodeCom">; system cursors</span>
        , b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13   <span class="CodeCom">; blank cursors</span>
        , h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13   <span class="CodeCom">; handles of default cursors</span>
    if (OnOff = &quot;Init&quot; or OnOff = &quot;I&quot; or $ = &quot;&quot;)       <span class="CodeCom">; init when requested or at first call</span>
    {
        $ = h                                          <span class="CodeCom">; active default cursors</span>
        VarSetCapacity( h_cursor,4444, 1 )
        VarSetCapacity( AndMask, 32*4, 0xFF )
        VarSetCapacity( XorMask, 32*4, 0 )
        system_cursors = 32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650
        StringSplit c, system_cursors, `,
        Loop %c0%
        {
            h_cursor   := DllCall( &quot;LoadCursor&quot;, &quot;uint&quot;,0, &quot;uint&quot;,c%A_Index% )
            h%A_Index% := DllCall( &quot;CopyImage&quot;,  &quot;uint&quot;,h_cursor, &quot;uint&quot;,2, &quot;int&quot;,0, &quot;int&quot;,0, &quot;uint&quot;,0 )
            b%A_Index% := DllCall(&quot;CreateCursor&quot;,&quot;uint&quot;,0, &quot;int&quot;,0, &quot;int&quot;,0
                , &quot;int&quot;,32, &quot;int&quot;,32, &quot;uint&quot;,&amp;AndMask, &quot;uint&quot;,&amp;XorMask )
        }
    }
    if (OnOff = 0 or OnOff = &quot;Off&quot; or $ = &quot;h&quot; and (OnOff &lt; 0 or OnOff = &quot;Toggle&quot; or OnOff = &quot;T&quot;))
        $ = b  <span class="CodeCom">; use blank cursors</span>
    else
        $ = h  <span class="CodeCom">; use the saved cursors</span>

    Loop %c0%
    {
        h_cursor := DllCall( &quot;CopyImage&quot;, &quot;uint&quot;,%$%%A_Index%, &quot;uint&quot;,2, &quot;int&quot;,0, &quot;int&quot;,0, &quot;uint&quot;,0 )
        DllCall( &quot;SetSystemCursor&quot;, &quot;uint&quot;,h_cursor, &quot;uint&quot;,c%A_Index% )
    }
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="ExStruct"></a><span class="CodeCom">; Structure Example: Pass the address of a RECT structure to GetWindowRect(), which sets the structure's</span>
<span class="CodeCom">; members to the positions of the left, top, right, and bottom sides of a window (relative to the screen).</span>

Run Notepad
WinWait Untitled - Notepad  <span class="CodeCom">; This also sets the &quot;<a href="../LastFoundWindow.htm">last found window</a>&quot; for use with WinExist() below.</span>
VarSetCapacity(Rect, 16)  <span class="CodeCom">; A RECT is a struct consisting of four 32-bit integers (i.e. 4*4=16).</span>
<strong>DllCall</strong>(&quot;GetWindowRect&quot;, UInt, WinExist(), UInt, &amp;Rect)  <span class="CodeCom">; WinExist() returns an HWND.</span>
MsgBox % &quot;Left &quot; . <a href="../Functions.htm#NumGet">NumGet</a>(Rect, 0, true) . &quot; Top &quot; . NumGet(Rect, 4, true)
    . &quot; Right &quot; . NumGet(Rect, 8, true) . &quot; Bottom &quot; . NumGet(Rect, 12, true)</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Structure Example: Pass to FillRect() the address of a RECT structure that indicates a part of the</span>
<span class="CodeCom">; screen to temporarily paint red.</span>

VarSetCapacity(Rect, 16, 0)  <span class="CodeCom">; Set capacity to hold four 4-byte integers and initialize them all to zero.</span>
<a href="../Functions.htm#NumPut">NumPut</a>(A_ScreenWidth//2, Rect, 8)  <span class="CodeCom">; The third integer in the structure is &quot;rect.right&quot;.</span>
NumPut(A_ScreenHeight//2, Rect, 12) <span class="CodeCom">; The fourth integer in the structure is &quot;rect.bottom&quot;.</span>
hDC := <strong>DllCall</strong>(&quot;GetDC&quot;, UInt, 0)  <span class="CodeCom">; Pass zero to get the desktop's device context.</span>
hBrush := <strong>DllCall</strong>(&quot;CreateSolidBrush&quot;, UInt, 0x0000FF)  <span class="CodeCom">; Create a red brush (0x0000FF is in BGR format).</span>
<strong>DllCall</strong>(&quot;FillRect&quot;, UInt, hDC, Str, Rect, UInt, hBrush)  <span class="CodeCom">; Fill the specified rectangle using the brush above.</span>
<strong>DllCall</strong>(&quot;ReleaseDC&quot;, UInt, 0, UInt, hDC)  <span class="CodeCom">; Clean-up.</span>
<strong>DllCall</strong>(&quot;DeleteObject&quot;, UInt, hBrush)  <span class="CodeCom">; Clean-up.</span></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom">; Structure Example: Change the system's clock to the specified date and time. Use caution when</span>
<span class="CodeCom">; changing to a date in the future as it may cause scheduled tasks to run prematurely!</span>

SetSystemTime(&quot;20051008142211&quot;)  <span class="CodeCom">; Pass it a <a href="FileSetTime.htm#YYYYMMDD">timestamp</a> (local, not UTC).</span>

SetSystemTime(YYYYMMDDHHMISS)
<span class="CodeCom">; Sets the system clock to the specified date and time.</span>
<span class="CodeCom">; Caller must ensure that the incoming parameter is a valid date-time stamp</span>
<span class="CodeCom">; (local time, not UTC). Returns non-zero upon success and zero otherwise.</span>
{
    <span class="CodeCom">; Convert the parameter from local time to UTC for use with SetSystemTime().</span>
    UTC_Delta -= %A_NowUTC%, Seconds  <span class="CodeCom">; Seconds is more accurate due to rounding issue.</span>
    UTC_Delta := Round(-UTC_Delta/60)  <span class="CodeCom">; Round to nearest minute to ensure accuracy.</span>
    YYYYMMDDHHMISS += %UTC_Delta%, Minutes  <span class="CodeCom">; Apply offset to convert to UTC.</span>

    VarSetCapacity(SystemTime, 16, 0)  <span class="CodeCom">; This struct consists of 8 UShorts (i.e. 8*2=16).</span>

    StringLeft, Int, YYYYMMDDHHMISS, 4    <span class="CodeCom">; YYYY (year)</span>
    <a href="../Functions.htm#NumPut">NumPut</a>(Int, SystemTime, 0, &quot;UShort&quot;)
    StringMid, Int, YYYYMMDDHHMISS, 5, 2  <span class="CodeCom">; MM (month of year, 1-12)</span>
    NumPut(Int, SystemTime, 2, &quot;UShort&quot;)
    StringMid, Int, YYYYMMDDHHMISS, 7, 2  <span class="CodeCom">; DD (day of month)</span>
    NumPut(Int, SystemTime, 6, &quot;UShort&quot;)
    StringMid, Int, YYYYMMDDHHMISS, 9, 2  <span class="CodeCom">; HH (hour in 24-hour time)</span>
    NumPut(Int, SystemTime, 8, &quot;UShort&quot;)
    StringMid, Int, YYYYMMDDHHMISS, 11, 2 <span class="CodeCom">; MI (minute)</span>
    NumPut(Int, SystemTime, 10, &quot;UShort&quot;)
    StringMid, Int, YYYYMMDDHHMISS, 13, 2 <span class="CodeCom">; SS (second)</span>
    NumPut(Int, SystemTime, 12, &quot;UShort&quot;)

    return <strong>DllCall</strong>(&quot;SetSystemTime&quot;, UInt, &amp;SystemTime)
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><span class="CodeCom"><strong>More Structure Examples:</strong>

1) See the <a href="../scripts/WinLIRC.htm">WinLIRC client script</a> for a demonstration of how to use DllCall() to make a network connection
to a TCP/IP server and receive data from it.

2) The operating system offers standard dialog boxes that prompt the user to pick a font and/or color, or an icon.
These dialogs use structures and are demonstrated at <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a>.</span></pre>

</body>
</html>
