<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>WinLIRC Client</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="alternate" type="application/rss+xml" title="AutoHotkey Forum RSS" href="/forum/rss.php">
<link href="/docs/css/default.css" rel="stylesheet" type="text/css">
<link href="/docs/css/print.css" rel="stylesheet" type="text/css" media="print">
<meta name="description" content="This open-source WinLIRC client can perform keystrokes, mouse clicks, and other actions in response to buttons you press on your remote control.">
</head>
<body>

<h6>WinLIRC Client</h6>

<p> This script receives notifications from <a href="http://winlirc.sourceforge.net">WinLIRC</a> whenever you press
 a button on your remote control. It can be used to automate Winamp,
 Windows Media Player, etc. It's easy to configure. For example, if
 WinLIRC recognizes a button named &quot;VolUp&quot; on your remote control,
 create a label named VolUp and beneath it use the command
 &quot;SoundSet +5&quot; to increase the soundcard's volume by 5%.
</p>
<p><a href="WinLIRC.ahk">Download This Script</a> &nbsp;| &nbsp;<a href="index.htm">Other Sample Scripts</a> &nbsp;| &nbsp;<a href="http://www.autohotkey.com">Home</a></p>
<hr>
<pre class="NoIndent"><span class="CodeCom">; Here are the steps to use this script:</span>
<span class="CodeCom">; 1) Configure WinLIRC to recognize your remote control and its buttons.</span>
<span class="CodeCom">;    WinLIRC is at <a href="http://winlirc.sourceforge.net">http://winlirc.sourceforge.net</a></span>
<span class="CodeCom">; 2) Edit the WinLIRC path, address, and port in the CONFIG section below.</span>
<span class="CodeCom">; 3) Launch this script. It will start the WinLIRC server if needed.</span>
<span class="CodeCom">; 4) Press some buttons on your remote control. A small window will</span>
<span class="CodeCom">;    appear showing the name of each button as you press it.</span>
<span class="CodeCom">; 5) Configure your buttons to send keystrokes and mouse clicks to</span>
<span class="CodeCom">;    windows such as Winamp, Media Player, etc. See the examples below.</span>

<span class="CodeCom">; This script requires AutoHotkey 1.0.38.04 or later.</span>
<span class="CodeCom">; HISTORY OF CHANGES</span>
<span class="CodeCom">; March 2, 2007:</span>
<span class="CodeCom">; - Improved reliability via &quot;Critical&quot; in ReceiveData().</span>
<span class="CodeCom">; October 5, 2005:</span>
<span class="CodeCom">; - Eliminated Winsock warning dialog &quot;10054&quot; upon system shutdown/logoff.</span>
<span class="CodeCom">; - Added option &quot;DelayBetweenButtonRepeats&quot; to throttle the repeat speed.</span>

<span class="CodeCom">; -------------------------------------------------</span>
<span class="CodeCom">; CONFIGURATION SECTION: Set your preferences here.</span>
<span class="CodeCom">; -------------------------------------------------</span>
<span class="CodeCom">; Some remote controls repeat the signal rapidly while you're holding down</span>
<span class="CodeCom">; a button. This makes it difficult to get the remote to send only a single</span>
<span class="CodeCom">; signal. The following setting solves this by ignoring repeated signals</span>
<span class="CodeCom">; until the specified time has passed. 200 is often a good setting.  Set it</span>
<span class="CodeCom">; to 0 to disable this feature.</span>
DelayBetweenButtonRepeats = 200

<span class="CodeCom">; Specify the path to WinLIRC, such as C:\WinLIRC\winlirc.exe</span>
WinLIRC_Path = %A_ProgramFiles%\WinLIRC\winlirc.exe

<span class="CodeCom">; Specify WinLIRC's address and port. The most common are 127.0.0.1 (localhost) and 8765.</span>
WinLIRC_Address = 127.0.0.1
WinLIRC_Port = 8765

<span class="CodeCom">; Do not change the following two lines. Skip them and continue below.</span>
Gosub WinLIRC_Init
return

<span class="CodeCom">; --------------------------------------------</span>
<span class="CodeCom">; ASSIGN ACTIONS TO THE BUTTONS ON YOUR REMOTE</span>
<span class="CodeCom">; --------------------------------------------</span>
<span class="CodeCom">; Configure your remote control's buttons below. Use WinLIRC's names</span>
<span class="CodeCom">; for the buttons, which can be seen in your WinLIRC config file</span>
<span class="CodeCom">; (.cf file) -- or you can press any button on your remote and the</span>
<span class="CodeCom">; script will briefly display the button's name in a small window.</span>
<span class="CodeCom">; </span>
<span class="CodeCom">; Below are some examples. Feel free to revise or delete them to suit</span>
<span class="CodeCom">; your preferences.</span>

VolUp:
SoundSet +5  <span class="CodeCom">; Increase master volume by 5%. On Vista, replace this line with: Send {Volume_Up}</span>
return

VolDown:
SoundSet -5  <span class="CodeCom">; Reduce master volume by 5%. On Vista, replace this line with: Send {Volume_Down}</span>
return

ChUp:
WinGetClass, ActiveClass, A
if ActiveClass in Winamp v1.x,Winamp PE  <span class="CodeCom">; Winamp is active.</span>
    Send {right}  <span class="CodeCom">; Send a right-arrow keystroke.</span>
else  <span class="CodeCom">; Some other type of window is active.</span>
    Send {WheelUp}  <span class="CodeCom">; Rotate the mouse wheel up by one notch.</span>
return

ChDown:
WinGetClass, ActiveClass, A
if ActiveClass in Winamp v1.x,Winamp PE  <span class="CodeCom">; Winamp is active.</span>
    Send {left}  <span class="CodeCom">; Send a left-arrow keystroke.</span>
else  <span class="CodeCom">; Some other type of window is active.</span>
    Send {WheelDown}  <span class="CodeCom">; Rotate the mouse wheel down by one notch.</span>
return

Menu:
IfWinExist, Untitled - Notepad
{
    WinActivate
}
else
{
    Run, Notepad
    WinWait, Untitled - Notepad
    WinActivate
}
Send Here are some keystrokes sent to Notepad.{Enter}
return

<span class="CodeCom">; The examples above give a feel for how to accomplish common tasks.</span>
<span class="CodeCom">; To learn the basics of AutoHotkey, check out the Quick-start Tutorial</span>
<span class="CodeCom">; at <a href="http://www.autohotkey.com/docs/Tutorial.htm">http://www.autohotkey.com/docs/Tutorial.htm</a></span>

<span class="CodeCom">; ----------------------------</span>
<span class="CodeCom">; END OF CONFIGURATION SECTION</span>
<span class="CodeCom">; ----------------------------</span>
<span class="CodeCom">; Do not make changes below this point unless you want to change the core</span>
<span class="CodeCom">; functionality of the script.</span>

WinLIRC_Init:
OnExit, ExitSub  <span class="CodeCom">; For connection cleanup purposes.</span>

<span class="CodeCom">; Launch WinLIRC if it isn't already running:</span>
Process, Exist, winlirc.exe
if not ErrorLevel  <span class="CodeCom">; No PID for WinLIRC was found.</span>
{
    IfNotExist, %WinLIRC_Path%
    {
        MsgBox The file &quot;%WinLIRC_Path%&quot; does not exist. Please edit this script to specify its location.
        ExitApp
    }
    Run %WinLIRC_Path%
    Sleep 200  <span class="CodeCom">; Give WinLIRC a little time to initialize (probably never needed, just for peace of mind).</span>
}

<span class="CodeCom">; Connect to WinLIRC (or any type of server for that matter):</span>
socket := ConnectToAddress(WinLIRC_Address, WinLIRC_Port)
if socket = -1  <span class="CodeCom">; Connection failed (it already displayed the reason).</span>
    ExitApp

<span class="CodeCom">; Find this script's main window:</span>
Process, Exist  <span class="CodeCom">; This sets ErrorLevel to this script's PID (it's done this way to support compiled scripts).</span>
DetectHiddenWindows On
ScriptMainWindowId := WinExist(&quot;ahk_class AutoHotkey ahk_pid &quot; . ErrorLevel)
DetectHiddenWindows Off

<span class="CodeCom">; When the OS notifies the script that there is incoming data waiting to be received,</span>
<span class="CodeCom">; the following causes a function to be launched to read the data:</span>
NotificationMsg = 0x5555  <span class="CodeCom">; An arbitrary message number, but should be greater than 0x1000.</span>
OnMessage(NotificationMsg, &quot;ReceiveData&quot;)

<span class="CodeCom">; Set up the connection to notify this script via message whenever new data has arrived.</span>
<span class="CodeCom">; This avoids the need to poll the connection and thus cuts down on resource usage.</span>
FD_READ = 1     <span class="CodeCom">; Received when data is available to be read.</span>
FD_CLOSE = 32   <span class="CodeCom">; Received when connection has been closed.</span>
if DllCall(&quot;Ws2_32\WSAAsyncSelect&quot;, &quot;UInt&quot;, socket, &quot;UInt&quot;, ScriptMainWindowId, &quot;UInt&quot;, NotificationMsg, &quot;Int&quot;, FD_READ|FD_CLOSE)
{
    MsgBox % &quot;WSAAsyncSelect() indicated Winsock error &quot; . DllCall(&quot;Ws2_32\WSAGetLastError&quot;)
    ExitApp
}
return



ConnectToAddress(IPAddress, Port)
<span class="CodeCom">; This can connect to most types of TCP servers, not just WinLIRC.</span>
<span class="CodeCom">; Returns -1 (INVALID_SOCKET) upon failure or the socket ID upon success.</span>
{
    VarSetCapacity(wsaData, 400)
    result := DllCall(&quot;Ws2_32\WSAStartup&quot;, &quot;UShort&quot;, 0x0002, &quot;UInt&quot;, &amp;wsaData) <span class="CodeCom">; Request Winsock 2.0 (0x0002)</span>
    <span class="CodeCom">; Since WSAStartup() will likely be the first Winsock function called by this script,</span>
    <span class="CodeCom">; check ErrorLevel to see if the OS has Winsock 2.0 available:</span>
    if ErrorLevel
    {
        MsgBox WSAStartup() could not be called due to error %ErrorLevel%. Winsock 2.0 or higher is required.
        return -1
    }
    if result  <span class="CodeCom">; Non-zero, which means it failed (most Winsock functions return 0 upon success).</span>
    {
        MsgBox % &quot;WSAStartup() indicated Winsock error &quot; . DllCall(&quot;Ws2_32\WSAGetLastError&quot;)
        return -1
    }

    AF_INET = 2
    SOCK_STREAM = 1
    IPPROTO_TCP = 6
    socket := DllCall(&quot;Ws2_32\socket&quot;, &quot;Int&quot;, AF_INET, &quot;Int&quot;, SOCK_STREAM, &quot;Int&quot;, IPPROTO_TCP)
    if socket = -1
    {
        MsgBox % &quot;socket() indicated Winsock error &quot; . DllCall(&quot;Ws2_32\WSAGetLastError&quot;)
        return -1
    }

    <span class="CodeCom">; Prepare for connection:</span>
    SizeOfSocketAddress = 16
    VarSetCapacity(SocketAddress, SizeOfSocketAddress)
    InsertInteger(2, SocketAddress, 0, AF_INET)   <span class="CodeCom">; sin_family</span>
    InsertInteger(DllCall(&quot;Ws2_32\htons&quot;, &quot;UShort&quot;, Port), SocketAddress, 2, 2)   <span class="CodeCom">; sin_port</span>
    InsertInteger(DllCall(&quot;Ws2_32\inet_addr&quot;, &quot;Str&quot;, IPAddress), SocketAddress, 4, 4)   <span class="CodeCom">; sin_addr.s_addr</span>

    <span class="CodeCom">; Attempt connection:</span>
    if DllCall(&quot;Ws2_32\connect&quot;, &quot;UInt&quot;, socket, &quot;UInt&quot;, &amp;SocketAddress, &quot;Int&quot;, SizeOfSocketAddress)
    {
        MsgBox % &quot;connect() indicated Winsock error &quot; . DllCall(&quot;Ws2_32\WSAGetLastError&quot;) . &quot;. Is WinLIRC running?&quot;
        return -1
    }
    return socket  <span class="CodeCom">; Indicate success by returning a valid socket ID rather than -1.</span>
}



ReceiveData(wParam, lParam)
<span class="CodeCom">; By means of OnMessage(), this function has been set up to be called automatically whenever new data</span>
<span class="CodeCom">; arrives on the connection.  It reads the data from WinLIRC and takes appropriate action depending</span>
<span class="CodeCom">; on the contents.</span>
{
    Critical  <span class="CodeCom">; Prevents another of the same message from being discarded due to thread-already-running.</span>
    socket := wParam
    ReceivedDataSize = 4096  <span class="CodeCom">; Large in case a lot of data gets buffered due to delay in processing previous data.</span>

    VarSetCapacity(ReceivedData, ReceivedDataSize, 0)  <span class="CodeCom">; 0 for last param terminates string for use with recv().</span>
    ReceivedDataLength := DllCall(&quot;Ws2_32\recv&quot;, &quot;UInt&quot;, socket, &quot;Str&quot;, ReceivedData, &quot;Int&quot;, ReceivedDataSize, &quot;Int&quot;, 0)
    if ReceivedDataLength = 0  <span class="CodeCom">; The connection was gracefully closed, probably due to exiting WinLIRC.</span>
        ExitApp  <span class="CodeCom">; The OnExit routine will call WSACleanup() for us.</span>
    if ReceivedDataLength = -1
    {
        WinsockError := DllCall(&quot;Ws2_32\WSAGetLastError&quot;)
        if WinsockError = 10035  <span class="CodeCom">; WSAEWOULDBLOCK, which means &quot;no more data to be read&quot;.</span>
            return 1
        if WinsockError &lt;&gt; 10054 <span class="CodeCom">; WSAECONNRESET, which happens when WinLIRC closes via system shutdown/logoff.</span>
            <span class="CodeCom">; Since it's an unexpected error, report it.  Also exit to avoid infinite loop.</span>
            MsgBox % &quot;recv() indicated Winsock error &quot; . WinsockError
        ExitApp  <span class="CodeCom">; The OnExit routine will call WSACleanup() for us.</span>
    }
    <span class="CodeCom">; Otherwise, process the data received. Testing shows that it's possible to get more than one line</span>
    <span class="CodeCom">; at a time (even for explicitly-sent IR signals), which the following method handles properly.</span>
    <span class="CodeCom">; Data received from WinLIRC looks like the following example (see the WinLIRC docs for details):</span>
    <span class="CodeCom">; 0000000000eab154 00 NameOfButton NameOfRemote</span>
    Loop, parse, ReceivedData, `n, `r
    {
        if A_LoopField in ,BEGIN,SIGHUP,END  <span class="CodeCom">; Ignore blank lines and WinLIRC's start-up messages.</span>
            continue
        ButtonName =  <span class="CodeCom">; Init to blank in case there are less than 3 fields found below.</span>
        Loop, parse, A_LoopField, %A_Space%  <span class="CodeCom">; Extract the button name, which is the third field.</span>
            if A_Index = 3
                ButtonName := A_LoopField
        global DelayBetweenButtonRepeats  <span class="CodeCom">; Declare globals to make them available to this function.</span>
        static PrevButtonName, PrevButtonTime, RepeatCount  <span class="CodeCom">; These variables remember their values between calls.</span>
        if (ButtonName != PrevButtonName || A_TickCount - PrevButtonTime &gt; DelayBetweenButtonRepeats)
        {
            if IsLabel(ButtonName)  <span class="CodeCom">; There is a subroutine associated with this button.</span>
                Gosub %ButtonName%  <span class="CodeCom">; Launch the subroutine.</span>
            else <span class="CodeCom">; Since there is no associated subroutine, briefly display which button was pressed.</span>
            {
                if (ButtonName == PrevButtonName)
                    RepeatCount += 1
                else
                    RepeatCount = 1
                SplashTextOn, 150, 20, Button from WinLIRC, %ButtonName% (%RepeatCount%)
                SetTimer, SplashOff, 3000  <span class="CodeCom">; This allows more signals to be processed while displaying the window.</span>
            }
            PrevButtonName := ButtonName
            PrevButtonTime := A_TickCount
        }
    }
    return 1  <span class="CodeCom">; Tell the program that no further processing of this message is needed.</span>
}



SplashOff:
SplashTextOff
SetTimer, SplashOff, Off
return



InsertInteger(pInteger, ByRef pDest, pOffset = 0, pSize = 4)
<span class="CodeCom">; The caller must ensure that pDest has sufficient capacity.  To preserve any existing contents in pDest,</span>
<span class="CodeCom">; only pSize number of bytes starting at pOffset are altered in it.</span>
{
    Loop %pSize%  <span class="CodeCom">; Copy each byte in the integer into the structure as raw binary data.</span>
        DllCall(&quot;RtlFillMemory&quot;, &quot;UInt&quot;, &amp;pDest + pOffset + A_Index-1, &quot;UInt&quot;, 1, &quot;UChar&quot;, pInteger &gt;&gt; 8*(A_Index-1) &amp; 0xFF)
}



ExitSub:  <span class="CodeCom">; This subroutine is called automatically when the script exits for any reason.</span>
<span class="CodeCom">; MSDN: &quot;Any sockets open when WSACleanup is called are reset and automatically</span>
<span class="CodeCom">; deallocated as if closesocket was called.&quot;</span>
DllCall(&quot;Ws2_32\WSACleanup&quot;)
ExitApp
</pre>
</body>
</html>
